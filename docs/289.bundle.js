/*! For license information please see 289.bundle.js.LICENSE.txt */
(self.webpackChunkhighlaight=self.webpackChunkhighlaight||[]).push([[289],{1289:(t,e,a)=>{"use strict";a.r(e),a.d(e,{HandPose:()=>fn,load:()=>hn});var n={};a.r(n),a.d(n,{json:()=>k});var s={};a.r(s),a.d(s,{json:()=>M});var r={};a.r(r),a.d(r,{json:()=>V});var o={};a.r(o),a.d(o,{json:()=>C});var p={};a.r(p),a.d(p,{json:()=>L});var i={};a.r(i),a.d(i,{json:()=>P});var m={};a.r(m),a.d(m,{json:()=>F});var u={};a.r(u),a.d(u,{json:()=>z});var d={};a.r(d),a.d(d,{json:()=>$});var c={};a.r(c),a.d(c,{json:()=>B});var y={};a.r(y),a.d(y,{json:()=>R});var l={};a.r(l),a.d(l,{json:()=>j});var h={};a.r(h),a.d(h,{json:()=>W});var f={};a.r(f),a.d(f,{json:()=>H});var g={};a.r(g),a.d(g,{json:()=>G});var N={};a.r(N),a.d(N,{json:()=>U});var x,b,T=a(3136);!function(t){t[t.DT_INVALID=0]="DT_INVALID",t[t.DT_FLOAT=1]="DT_FLOAT",t[t.DT_DOUBLE=2]="DT_DOUBLE",t[t.DT_INT32=3]="DT_INT32",t[t.DT_UINT8=4]="DT_UINT8",t[t.DT_INT16=5]="DT_INT16",t[t.DT_INT8=6]="DT_INT8",t[t.DT_STRING=7]="DT_STRING",t[t.DT_COMPLEX64=8]="DT_COMPLEX64",t[t.DT_INT64=9]="DT_INT64",t[t.DT_BOOL=10]="DT_BOOL",t[t.DT_QINT8=11]="DT_QINT8",t[t.DT_QUINT8=12]="DT_QUINT8",t[t.DT_QINT32=13]="DT_QINT32",t[t.DT_BFLOAT16=14]="DT_BFLOAT16",t[t.DT_FLOAT_REF=101]="DT_FLOAT_REF",t[t.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",t[t.DT_INT32_REF=103]="DT_INT32_REF",t[t.DT_UINT8_REF=104]="DT_UINT8_REF",t[t.DT_INT16_REF=105]="DT_INT16_REF",t[t.DT_INT8_REF=106]="DT_INT8_REF",t[t.DT_STRING_REF=107]="DT_STRING_REF",t[t.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",t[t.DT_INT64_REF=109]="DT_INT64_REF",t[t.DT_BOOL_REF=110]="DT_BOOL_REF",t[t.DT_QINT8_REF=111]="DT_QINT8_REF",t[t.DT_QUINT8_REF=112]="DT_QUINT8_REF",t[t.DT_QINT32_REF=113]="DT_QINT32_REF",t[t.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF"}(x||(x={})),function(t){let e;!function(t){t[t.LEGACY=0]="LEGACY",t[t.V1=1]="V1",t[t.V2=2]="V2"}(e=t.CheckpointFormatVersion||(t.CheckpointFormatVersion={}))}(b||(b={}));const S={};function w(t){return S[t]}function O(t,e,a,n){const s=e.inputParams[t];if(s&&void 0!==s.inputIndexStart){const t=s.inputIndexStart,r=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?t+1:s.inputIndexEnd;if("tensor"===s.type)return _(e.inputNames[s.inputIndexStart],a,n);if("tensors"===s.type)return e.inputNames.slice(t,r).map((t=>_(t,a,n)));const o=_(e.inputNames.slice(t)[0],a,n),p=o.dataSync();return"number"===s.type?p[0]:T.util.toNestedArray(o.shape,p)}const r=e.attrParams[t];return r&&r.value}function _(t,e,a){const[n,s]=E(t),r=a.currentContextIds.find((t=>!!e[I(n,t)]));return void 0!==r?e[I(n,r)][s]:void 0}function v(t,e){const[a,n]=E(t);return[I(a,e&&e.currentContextId),n]}function I(t,e){return e?`${t}-${e}`:t}function E(t){const e=t.split(":");return 1===e.length?[t,0]:[e[0],Number(e[e.length-1])]}function A(t,e,a){let n=O("pad",t,e,a);if("explicit"===n){n=O("explicitPaddings",t,e,a);const s=[[0,0],[0,0],[0,0],[0,0]];for(let t=0;t<4;t++)s[t][0]=n[2*t],s[t][1]=n[2*t+1];return s}return n}function D(t){return t.kept?t:(0,T.clone)(t)}const k=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],M=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"clip_value_min",name:"clipValueMin",type:"number"},{tfName:"clip_value_max",name:"clipValueMax",type:"number"}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"clipValueMin",name:"clipValueMin",type:"number",defaultValue:0},{tfName:"clipValueMax",name:"clipValueMax",type:"number",defaultValue:6}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],V=[{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]}],C=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],L=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],P=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],F=[{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]}],z=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],$=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]}],B=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],R=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],j=[{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],W=[{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],H=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool",notSupported:!0}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],G=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],U=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]}];function q(t,e){const a=Array.isArray(t)?String.fromCharCode.apply(null,t):function(t){const e=(0,T.env)().global;if(void 0!==e.atob)return e.atob(t);if("undefined"!=typeof Buffer)return new Buffer(t,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(t);return e?a:a.toLowerCase()}function K(t,e,a,n=!1){const s=t[e];return null!=s?q(s.s,n):a}function Q(t,e,a){const n=t[e];return n?n.b:a}function X(t,e,a){const n=t[e]||{},s=null!=n.i?n.i:null!=n.f?n.f:a;return"number"==typeof s?s:parseInt(s,10)}function Y(t){switch("string"==typeof t&&(t=x[t]),t){case x.DT_FLOAT:return"float32";case x.DT_INT32:case x.DT_INT64:case x.DT_INT8:case x.DT_UINT8:return"int32";case x.DT_BOOL:return"bool";case x.DT_DOUBLE:return"float32";case x.DT_STRING:return"string";default:return null}}function Z(t,e,a){const n=t[e];return n&&n.func?n.func.name:a}function J(t,e,a){const n=t[e];return n&&n.type?Y(n.type):a}function tt(t,e,a){const n=t[e];return n&&n.list&&n.list.type?n.list.type.map((t=>Y(t))):a}function et(t){if(!t.unknownRank)return null!=t.dim?t.dim.map((t=>"number"==typeof t.size?t.size:parseInt(t.size,10))):[]}function at(t,e,a){const n=t[e];return n&&n.shape?et(n.shape):a}function nt(t,e,a){const n=t[e];return n?((n.list.f&&n.list.f.length?n.list.f:n.list.i)||[]).map((t=>"number"==typeof t?t:parseInt(t,10))):a}function st(t,e,a,n=!1){const s=t[e];return s&&s.list&&s.list.s?s.list.s.map((t=>q(t,n))):a}function rt(t,e,a){const n=t[e];return n&&n.list&&n.list.shape?n.list.shape.map((t=>et(t))):a}function ot(t,e,a){const n=t[e];return n&&n.list&&n.list.b?n.list.b:a}class pt{constructor(t,e,a){this.node=t,this.tensorMap=e,this.context=a,this.inputs=[],this.attrs={},this.inputs=t.inputNames.map((t=>this.getInput(t))),null!=t.rawAttrs&&(this.attrs=Object.keys(t.rawAttrs).reduce(((t,e)=>(t[e]=this.getAttr(e),t)),{}))}getInput(t){return _(t,this.tensorMap,this.context)}getAttr(t,e){const a=this.node.rawAttrs[t];if(null!=a.tensor)return _(t,this.tensorMap,this.context);if(null!=a.i||null!=a.f)return X(this.node.rawAttrs,t,e);if(null!=a.s)return K(this.node.rawAttrs,t,e);if(null!=a.b)return Q(this.node.rawAttrs,t,e);if(null!=a.shape)return at(this.node.rawAttrs,t,e);if(null!=a.type)return J(this.node.rawAttrs,t,e);if(null!=a.list){if(null!=a.list.i||null!=a.list.f)return nt(this.node.rawAttrs,t,e);if(null!=a.list.s)return st(this.node.rawAttrs,t,e);if(null!=a.list.shape)return rt(this.node.rawAttrs,t,e);if(null!=a.list.b)return ot(this.node.rawAttrs,t,e);if(null!=a.list.type)return tt(this.node.rawAttrs,t,e)}return e}}var it=a(6407),mt=a(3135),ut=a(5228),dt=a(4841),ct=a(1274),yt=a(9322),lt=a(9165),ht=a(827),ft=a(4513),gt=a(632),Nt=a(3453),xt=a(5265),bt=a(6235),Tt=a(7839),St=a(1470),wt=a(2421),Ot=a(1891),_t=a(7037),vt=a(9812),It=a(369),Et=a(6825),At=a(1661),Dt=a(173),kt=a(2699),Mt=a(3233),Vt=a(4650),Ct=a(4842),Lt=a(3426),Pt=a(6943),Ft=a(2597),zt=a(7474),$t=a(4386),Bt=a(7370),Rt=a(9036),jt=a(766),Wt=a(7409),Ht=a(7809),Gt=a(5503),Ut=a(625),qt=a(9331),Kt=a(4434),Qt=a(3254),Xt=a(3694),Yt=a(3261),Zt=a(248),Jt=a(1869),te=a(1173),ee=a(2279),ae=a(2634),ne=a(9451),se=a(9133),re=a(8151);function oe(t,e,a=""){T.util.assert(function(t,e){if(t.length!==e.length)return!1;for(let a=0;a<t.length;a++)if(-1!==t[a]&&-1!==e[a]&&t[a]!==e[a])return!1;return!0}(t,e),(()=>a+` Shapes ${t} and ${e} must match`))}class pe{constructor(t,e,a,n,s,r,o){this.name=t,this.dtype=e,this.maxSize=a,this.elementShape=n,this.identicalElementShapes=s,this.dynamicSize=r,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=(0,T.scalar)(0),(0,T.keep)(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.tensor.id)||e.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(t){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||t>=this.size())throw new Error(`Tried to read from index ${t}, but array size is: ${this.size()}`);const e=this.tensors[t];if(e.cleared)throw new Error(`TensorArray ${this.name}: Could not read index ${t} twice because it was cleared after a previous read (perhaps try setting clear_after_read = false?).`);return this.clearAfterRead&&(e.cleared=!0),e.read=!0,e.tensor}readMany(t){return t.map((t=>this.read(t)))}write(t,e){if(this.closed_)throw new Error(`TensorArray ${this.name} has already been closed.`);if(t<0||!this.dynamicSize&&t>=this.maxSize)throw new Error(`Tried to write to index ${t}, but array is not resizeable and size is: ${this.maxSize}`);const a=this.tensors[t]||{};if(e.dtype!==this.dtype)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t},\n          because the value dtype is ${e.dtype}, but TensorArray dtype is ${this.dtype}.`);if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=e.shape),oe(this.elementShape,e.shape,`TensorArray ${this.name}: Could not write to TensorArray index ${t}.`),a.read)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been read.`);if(a.written)throw new Error(`TensorArray ${this.name}: Could not write to TensorArray index ${t}, because it has already been written.`);a.tensor=e,(0,T.keep)(e),a.written=!0,this.tensors[t]=a}writeMany(t,e){if(t.length!==e.length)throw new Error(`TensorArray ${this.name}: could not write multiple tensors,because the index size: ${t.length} is not the same as tensors size: ${e.length}.`);t.forEach(((t,a)=>this.write(t,e[a])))}gather(t,e){if(e&&e!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but gather requested dtype ${e}`);if(t)t=t.slice(0,this.size());else{t=[];for(let e=0;e<this.size();e++)t.push(e)}if(0===t.length)return(0,T.tensor)([],[0].concat(this.elementShape));const a=this.readMany(t);return oe(this.elementShape,a[0].shape,"TensorArray shape mismatch: "),(0,T.stack)(a,0)}concat(t){if(t&&t!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but concat requested dtype ${t}`);if(0===this.size())return(0,T.tensor)([],[0].concat(this.elementShape));const e=[];for(let t=0;t<this.size();t++)e.push(t);const a=this.readMany(e);return oe(this.elementShape,a[0].shape,`TensorArray shape mismatch: tensor array shape (${this.elementShape}) vs first tensor shape (${a[0].shape})`),(0,T.concat)(a,0)}scatter(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);if(t.length!==e.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${t.length} vs. ${e.shape[0]}`);const a=Math.max(...t);if(!this.dynamicSize&&a>=this.maxSize)throw new Error(`Max index must be < array size (${a}  vs. ${this.maxSize})`);this.writeMany(t,(0,T.unstack)(e,0))}split(t,e){if(e.dtype!==this.dtype)throw new Error(`TensorArray dtype is ${this.dtype} but tensor has dtype ${e.dtype}`);let a=0;const n=t.map((t=>(a+=t,a)));if(a!==e.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${a}, and tensor's shape is: ${e.shape}`);if(!this.dynamicSize&&t.length!==this.maxSize)throw new Error(`TensorArray's size is not equal to the size of lengths (${this.maxSize} vs. ${t.length}), and the TensorArray is not marked as dynamically resizeable`);const s=0===a?0:e.size/a,r=[];(0,T.tidy)((()=>{e=(0,T.reshape)(e,[1,a,s]);for(let a=0;a<t.length;++a){const o=[0,0===a?0:n[a-1],0],p=[1,t[a],s];r[a]=(0,T.reshape)((0,T.slice)(e,o,p),this.elementShape)}return r}));const o=[];for(let e=0;e<t.length;e++)o[e]=e;this.writeMany(o,r)}}class ie{constructor(t,e,a,n=-1){this.tensors=t,this.elementShape=e,this.elementDtype=a,null!=t&&t.forEach((t=>{if(a!==t.dtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${t.dtype}`);oe(e,t.shape,"TensorList shape mismatch: "),(0,T.keep)(t)})),this.idTensor=(0,T.scalar)(0),this.maxNumElements=n,(0,T.keep)(this.idTensor)}get id(){return this.idTensor.id}copy(){return new ie([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(t){this.tensors.forEach((e=>{null!=t&&t.has(e.id)||e.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(t,e,a=-1){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(-1!==a&&this.tensors.length!==a)throw new Error(`Operation expected a list with ${a} elements but got a list with ${this.tensors.length} elements.`);return oe(t,this.elementShape,"TensorList shape mismatch: "),(0,T.tidy)((()=>{const e=this.tensors.map((e=>(0,T.reshape)(e,t)));return(0,T.stack)(e,0)}))}popBack(t,e){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);if(0===this.size())throw new Error("Trying to pop from an empty list.");const a=this.tensors.pop();return oe(a.shape,t,"TensorList shape mismatch: "),(0,T.reshape)(a,t)}pushBack(t){if(t.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${this.elementDtype}`);if(oe(t.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");(0,T.keep)(t),this.tensors.push(t)}resize(t){if(t<0)throw new Error(`TensorListResize expects size to be non-negative. Got: ${t}`);if(-1!==this.maxNumElements&&t>this.maxNumElements)throw new Error(`TensorListResize input size ${t} is greater maxNumElement ${this.maxNumElements}.`);this.tensors.length=t}getItem(t,e,a){if(a!==this.elementDtype)throw new Error(`Invalid data types; op elements ${a}, but list elements ${this.elementDtype}`);if(t<0||t>this.tensors.length)throw new Error(`Trying to access element ${t} in a list with ${this.tensors.length} elements.`);if(null==this.tensors[t])throw new Error(`element at index ${t} is null.`);return oe(this.tensors[t].shape,e,"TensorList shape mismatch: "),this.tensors[t]}setItem(t,e){if(e.dtype!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e.dtype}, but list elements ${this.elementDtype}`);if(t<0||-1!==this.maxNumElements&&t>=this.maxNumElements)throw new Error(`Trying to set element ${t} in a list with max ${this.maxNumElements} elements.`);oe(this.elementShape,e.shape,"TensorList shape mismatch: "),(0,T.keep)(e),this.tensors[t]=e}gather(t,e,a){if(e!==this.elementDtype)throw new Error(`Invalid data types; op elements ${e}, but list elements ${this.elementDtype}`);return oe(this.elementShape,a,"TensorList shape mismatch: "),0===(t=t.slice(0,this.size())).length?(0,T.tensor)([],[0].concat(this.elementShape)):(0,T.tidy)((()=>{const e=t.map((t=>(0,T.reshape)(this.tensors[t],a)));return(0,T.stack)(e,0)}))}concat(t,e){if(t&&t!==this.elementDtype)throw new Error(`TensorList dtype is ${this.elementDtype} but concat requested dtype ${t}`);return oe(this.elementShape,e,"TensorList shape mismatch: "),0===this.size()?(0,T.tensor)([],[0].concat(this.elementShape)):(0,T.tidy)((()=>{const t=this.tensors.map((t=>(0,T.reshape)(t,e)));return(0,T.concat)(t,0)}))}}var me=a(1355),ue=a(4794),de=a(4624),ce=a(1405),ye=a(4718),le=a(473),he=a(5176),fe=a(1174),ge=a(6877),Ne=a(1749),xe=a(5020),be=a(557);function Te(t,e,a){const[n,s]=O("fusedOps",t,e,a),r="biasadd"===n,o="prelu"===s,p="fusedbatchnorm"===n,i=O("numArgs",t,e,a);if(r){if(o&&2!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==i)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(p)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported.");const m=O("strides",t,e,a),u=A(t,e,a),d=O("dataFormat",t,e,a).toUpperCase(),c=O("dilations",t,e,a),[y,l]=O("args",t,e,a);return{stride:m,pad:u,dataFormat:d,dilations:c,biasArg:y,preluArg:l,activationFunc:s}}var Se=a(4006),we=a(4135),Oe=a(686),_e=a(6708),ve=a(4917),Ie=a(7846),Ee=a(5002),Ae=a(7245),De=a(3596),ke=a(9640),Me=a(6577),Ve=a(1395),Ce=a(2271),Le=a(6380),Pe=a(6567);function Fe(t,e,a){return{boxes:O("boxes",t,e,a),scores:O("scores",t,e,a),maxOutputSize:O("maxOutputSize",t,e,a),iouThreshold:O("iouThreshold",t,e,a),scoreThreshold:O("scoreThreshold",t,e,a),softNmsSigma:O("softNmsSigma",t,e,a)}}var ze=a(3243),$e=a(6092),Be=a(9494),Re=a(6477),je=a(6500),We=a(636),He=a(7630),Ge=a(6573),Ue=a(624),qe=a(2856),Ke=a(8651),Qe=a(5750),Xe=a(5912),Ye=a(8687),Ze=a(9065),Je=a(7505),ta=a(9648),ea=a(682),aa=a(1510),na=a(9758),sa=a(3307),ra=a(5130),oa=a(5735),pa=a(5475),ia=a(781),ma=a(2998),ua=a(47),da=a(7394),ca=a(7405),ya=a(6884),la=a(4926),ha=a(7486),fa=a(2676),ga=a(5158),Na=a(9590),xa=a(4968),ba=a(2991),Ta=a(4136),Sa=a(7501),wa=a(8644),Oa=a(3100),_a=a(7494),va=a(7020),Ia=a(8447),Ea=a(3710),Aa=a(4415),Da=a(1300),ka=a(9682),Ma=a(7918),Va=a(8441),Ca=a(9112),La=a(8247);function Pa(t,e,a){const n=((t,e,a)=>{switch(t.category){case"arithmetic":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"BiasAdd":case"AddV2":case"Add":return[it.I(O("a",t,e,a),O("b",t,e,a))];case"AddN":return[mt.Q(O("tensors",t,e,a))];case"FloorMod":case"Mod":return[ut.w(O("a",t,e,a),O("b",t,e,a))];case"Mul":return[dt.d(O("a",t,e,a),O("b",t,e,a))];case"RealDiv":case"Div":return[ct.h(O("a",t,e,a),O("b",t,e,a))];case"DivNoNan":return[yt.N(O("a",t,e,a),O("b",t,e,a))];case"FloorDiv":return[lt.q(O("a",t,e,a),O("b",t,e,a))];case"Sub":return[ht.l(O("a",t,e,a),O("b",t,e,a))];case"Minimum":return[ft.L(O("a",t,e,a),O("b",t,e,a))];case"Maximum":return[gt.g(O("a",t,e,a),O("b",t,e,a))];case"Pow":return[Nt.s(O("a",t,e,a),O("b",t,e,a))];case"SquaredDifference":return[xt.$(O("a",t,e,a),O("b",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"basic_math":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Abs":case"ComplexAbs":return[bt.W(O("x",t,e,a))];case"Acos":return[Tt.K(O("x",t,e,a))];case"Acosh":return[St._(O("x",t,e,a))];case"Asin":return[wt.Z(O("x",t,e,a))];case"Asinh":return[Ot.V(O("x",t,e,a))];case"Atan":return[_t.z(O("x",t,e,a))];case"Atan2":return[vt.f(O("x",t,e,a),O("y",t,e,a))];case"Atanh":return[It.C(O("x",t,e,a))];case"Ceil":return[Et.m(O("x",t,e,a))];case"Complex":return[At.P(O("real",t,e,a),O("imag",t,e,a))];case"Cos":return[Dt.m(O("x",t,e,a))];case"Cosh":return[kt.f(O("x",t,e,a))];case"Elu":return[Mt.p(O("x",t,e,a))];case"Erf":return[Vt.q(O("x",t,e,a))];case"Exp":return[Ct.Q(O("x",t,e,a))];case"Expm1":return[Lt.t(O("x",t,e,a))];case"Floor":return[Pt.G(O("x",t,e,a))];case"Log":return[Ft.c(O("x",t,e,a))];case"Log1p":return[zt.K(O("x",t,e,a))];case"Imag":return[$t.a(O("x",t,e,a))];case"Neg":return[Bt.W(O("x",t,e,a))];case"Reciprocal":return[Rt.M(O("x",t,e,a))];case"Real":return[jt.k(O("x",t,e,a))];case"Relu":return[Wt.U(O("x",t,e,a))];case"Round":return[Ht.N(O("x",t,e,a))];case"Selu":return[Gt.U(O("x",t,e,a))];case"Sigmoid":return[Ut.X(O("x",t,e,a))];case"Sin":return[qt.O(O("x",t,e,a))];case"Sign":return[Kt.X(O("x",t,e,a))];case"Sinh":return[Qt.R(O("x",t,e,a))];case"Softplus":return[Xt.W(O("x",t,e,a))];case"Sqrt":return[Yt._(O("x",t,e,a))];case"Square":return[Zt.h(O("x",t,e,a))];case"Tanh":return[Jt.A(O("x",t,e,a))];case"Tan":return[te.O(O("x",t,e,a))];case"Relu6":case"ClipByValue":return[ee.i(O("x",t,e,a),O("clipValueMin",t,e,a),O("clipValueMax",t,e,a))];case"Rsqrt":return[ae.b(_(t.inputNames[0],e,a))];case"Prod":return[ne.W(O("x",t,e,a),O("axes",t,e,a))];case"LeakyRelu":return[se.h(O("x",t,e,a),O("alpha",t,e,a))];case"Prelu":return[re.A(O("x",t,e,a),O("alpha",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"control":return(async(t,e,a)=>{switch(t.op){case"If":case"StatelessIf":{const n=O("thenBranch",t,e,a),s=O("elseBranch",t,e,a),r=O("cond",t,e,a),o=O("args",t,e,a);return(await r.data())[0]?a.functionMap[n].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap):a.functionMap[s].executeFunctionAsync(o,a.tensorArrayMap,a.tensorListMap)}case"While":case"StatelessWhile":{const n=O("body",t,e,a),s=O("cond",t,e,a),r=O("args",t,e,a),o=await a.functionMap[s].executeFunctionAsync(r,a.tensorArrayMap,a.tensorListMap),p=r.map((t=>t.id));let i=await o[0].data();o.forEach((t=>{t.kept||-1!==p.indexOf(t.id)||t.dispose()}));let m=r;for(;i[0];){const t=m;m=await a.functionMap[n].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);const e=m.map((t=>t.id));t.forEach((t=>{t.kept||-1!==p.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}));const r=await a.functionMap[s].executeFunctionAsync(m,a.tensorArrayMap,a.tensorListMap);i=await r[0].data(),r.forEach((t=>{t.kept||-1!==p.indexOf(t.id)||-1!==e.indexOf(t.id)||t.dispose()}))}return m}case"LoopCond":return[D(O("pred",t,e,a))];case"Switch":{const n=O("pred",t,e,a);let s=O("data",t,e,a);return s.kept||(s=D(s)),(await n.data())[0]?[void 0,s]:[s,void 0]}case"Merge":{const n=t.inputNames.find((t=>void 0!==_(t,e,a)));return n?[D(_(n,e,a))]:void 0}case"Enter":{const n=O("frameName",t,e,a),s=O("tensor",t,e,a);return a.enterFrame(n),[D(s)]}case"Exit":{const n=O("tensor",t,e,a);return a.exitFrame(),[D(n)]}case"NextIteration":{const n=O("tensor",t,e,a);return a.nextIteration(),[D(n)]}case"TensorArrayV3":{const n=O("size",t,e,a),s=O("dtype",t,e,a),r=O("elementShape",t,e,a),o=O("dynamicSize",t,e,a),p=O("clearAfterRead",t,e,a),i=O("identicalElementShapes",t,e,a),m=O("name",t,e,a),u=new pe(m,s,n,r,i,o,p);return a.addTensorArray(u),[u.idTensor,(0,T.scalar)(1)]}case"TensorArrayWriteV3":{const n=O("tensorArrayId",t,e,a),s=O("index",t,e,a),r=O("tensor",t,e,a),o=a.getTensorArray(n.id);return o.write(s,r),[o.idTensor]}case"TensorArrayReadV3":{const n=O("tensorArrayId",t,e,a),s=O("index",t,e,a);return[a.getTensorArray(n.id).read(s)]}case"TensorArrayGatherV3":{const n=O("tensorArrayId",t,e,a),s=O("indices",t,e,a),r=O("dtype",t,e,a);return[a.getTensorArray(n.id).gather(s,r)]}case"TensorArrayScatterV3":{const n=O("tensorArrayId",t,e,a),s=O("indices",t,e,a),r=O("tensor",t,e,a),o=a.getTensorArray(n.id);return o.scatter(s,r),[o.idTensor]}case"TensorArrayConcatV3":{const n=O("tensorArrayId",t,e,a),s=a.getTensorArray(n.id),r=O("dtype",t,e,a);return[s.concat(r)]}case"TensorArraySplitV3":{const n=O("tensorArrayId",t,e,a),s=O("tensor",t,e,a),r=O("lengths",t,e,a),o=a.getTensorArray(n.id);return o.split(r,s),[o.idTensor]}case"TensorArraySizeV3":{const n=O("tensorArrayId",t,e,a),s=a.getTensorArray(n.id);return[(0,T.scalar)(s.size(),"int32")]}case"TensorArrayCloseV3":{const n=O("tensorArrayId",t,e,a),s=a.getTensorArray(n.id);return s.clearAndClose(),[s.idTensor]}case"TensorListSetItem":{const n=O("tensorListId",t,e,a),s=O("index",t,e,a),r=O("tensor",t,e,a),o=a.getTensorList(n.id);return o.setItem(s,r),[o.idTensor]}case"TensorListGetItem":{const n=O("tensorListId",t,e,a),s=O("index",t,e,a),r=O("elementShape",t,e,a),o=O("elementDType",t,e,a);return[a.getTensorList(n.id).getItem(s,r,o)]}case"TensorListScatterV2":case"TensorListScatter":{const n=O("indices",t,e,a),s=function(t,e,a,n){if(e.length!==t.shape[0])throw new Error(`Expected len(indices) == tensor.shape[0], but saw: ${e.length} vs. ${t.shape[0]}`);const s=Math.max(...e);if(null!=n&&-1!==n&&s>=n)throw new Error(`Max index must be < array size (${s}  vs. ${n})`);const r=new ie([],a,t.dtype,n),o=(0,T.unstack)(t,0);return e.forEach(((t,e)=>{r.setItem(t,o[e])})),r}(O("tensor",t,e,a),n,O("elementShape",t,e,a),O("numElements",t,e,a));return a.addTensorList(s),[s.idTensor]}case"TensorListReserve":{const o=(n=O("elementShape",t,e,a),s=O("elementDType",t,e,a),r=O("numElements",t,e,a),new ie([],n,s,r));return a.addTensorList(o),[o.idTensor]}case"TensorListGather":{const n=O("tensorListId",t,e,a),s=O("indices",t,e,a),r=O("elementShape",t,e,a),o=O("elementDType",t,e,a);return[a.getTensorList(n.id).gather(s,o,r)]}case"TensorListStack":{const n=O("tensorListId",t,e,a),s=O("elementShape",t,e,a),r=O("elementDType",t,e,a),o=O("numElements",t,e,a);return[a.getTensorList(n.id).stack(s,r,o)]}case"TensorListFromTensor":{const n=function(t,e,a){const n=t.dtype;if(t.shape.length<1)throw new Error(`Tensor must be at least a vector, but saw shape: ${t.shape}`);if(t.dtype!==a)throw new Error(`Invalid data types; op elements ${t.dtype}, but list elements ${a}`);oe(t.shape.slice(1),e,"TensorList shape mismatch: ");const s=(0,T.unstack)(t);return new ie(s,e,n)}(O("tensor",t,e,a),O("elementShape",t,e,a),O("elementDType",t,e,a));return a.addTensorList(n),[n.idTensor]}case"TensorListConcat":{const n=O("tensorListId",t,e,a),s=a.getTensorList(n.id),r=O("dtype",t,e,a),o=O("elementShape",t,e,a);return[s.concat(r,o)]}case"TensorListPushBack":{const n=O("tensorListId",t,e,a),s=O("tensor",t,e,a),r=a.getTensorList(n.id);return r.pushBack(s),[r.idTensor]}case"TensorListPopBack":{const n=O("tensorListId",t,e,a),s=O("elementShape",t,e,a),r=O("elementDType",t,e,a);return[a.getTensorList(n.id).popBack(s,r)]}case"TensorListSplit":{const n=O("tensor",t,e,a),s=O("elementShape",t,e,a),r=function(t,e,a){let n=0;const s=e.map((t=>(n+=t,n)));if(n!==t.shape[0])throw new Error(`Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ${n}, and tensor's shape is: ${t.shape}`);const r=0===n?0:t.size/n,o=(0,T.tidy)((()=>{const o=[];t=(0,T.reshape)(t,[1,n,r]);for(let n=0;n<e.length;++n){const p=[0,0===n?0:s[n-1],0],i=[1,e[n],r];o[n]=(0,T.reshape)((0,T.slice)(t,p,i),a)}return t.dispose(),o})),p=new ie([],a,t.dtype,e.length);for(let t=0;t<o.length;t++)p.setItem(t,o[t]);return p}(n,O("lengths",t,e,a),s);return a.addTensorList(r),[r.idTensor]}default:throw TypeError(`Node type ${t.op} is not implemented`)}var n,s,r})(t,e,a);case"convolution":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Conv1D":{const n=O("stride",t,e,a),s=O("pad",t,e,a),r=O("dataFormat",t,e,a).toUpperCase(),o=O("dilation",t,e,a);return[me.P(O("x",t,e,a),O("filter",t,e,a),n,s,r,o)]}case"Conv2D":{const n=O("strides",t,e,a),s=A(t,e,a),r=O("dataFormat",t,e,a).toUpperCase(),o=O("dilations",t,e,a);return[ue.T(O("x",t,e,a),O("filter",t,e,a),[n[1],n[2]],s,r,[o[1],o[2]])]}case"_FusedConv2D":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m}=Te(t,e,a);return[de.conv2d({x:O("x",t,e,a),filter:O("filter",t,e,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i})]}case"FusedDepthwiseConv2dNative":{const{stride:n,pad:s,dataFormat:r,dilations:o,biasArg:p,preluArg:i,activationFunc:m}=Te(t,e,a);return[de.depthwiseConv2d({x:O("x",t,e,a),filter:O("filter",t,e,a),strides:[n[1],n[2]],pad:s,dataFormat:r,dilations:[o[1],o[2]],bias:p,activation:m,preluActivationWeights:i})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const n=O("outputShape",t,e,a),s=O("strides",t,e,a),r=A(t,e,a);return[ce.b(O("x",t,e,a),O("filter",t,e,a),n,[s[1],s[2]],r)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const n=O("strides",t,e,a),s=A(t,e,a),r=O("dilations",t,e,a),o=O("dataFormat",t,e,a).toUpperCase();return[ye.B(O("input",t,e,a),O("filter",t,e,a),[n[1],n[2]],s,o,[r[1],r[2]])]}case"Conv3D":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("dataFormat",t,e,a).toUpperCase(),o=O("dilations",t,e,a);return[le.p(O("x",t,e,a),O("filter",t,e,a),[n[1],n[2],n[3]],s,r,[o[1],o[2],o[3]])]}case"AvgPool":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("kernelSize",t,e,a);return[he.w(O("x",t,e,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPool":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("kernelSize",t,e,a);return[fe._(O("x",t,e,a),[r[1],r[2]],[n[1],n[2]],s)]}case"MaxPoolWithArgmax":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("kernelSize",t,e,a),o=O("includeBatchInIndex",t,e,a),{result:p,indexes:i}=ge.I(O("x",t,e,a),[r[1],r[2]],[n[1],n[2]],s,o);return[p,i]}case"AvgPool3D":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("kernelSize",t,e,a);return[Ne.u(O("x",t,e,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"MaxPool3D":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("kernelSize",t,e,a);return[xe.Y(O("x",t,e,a),[r[1],r[2],r[3]],[n[1],n[2],n[3]],s)]}case"Dilation2D":{const n=O("strides",t,e,a),s=O("pad",t,e,a),r=O("dilations",t,e,a),o=n[1],p=n[2],i=r[1],m=r[2];return[be.W(O("x",t,e,a),O("filter",t,e,a),[o,p],s,[i,m],"NHWC")]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"creation":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Fill":{const n=O("shape",t,e,a),s=O("dtype",t,e,a),r=O("value",t,e,a);return[Se.h(n,r,s)]}case"LinSpace":{const n=O("start",t,e,a),s=O("stop",t,e,a),r=O("num",t,e,a);return[we.S(n,s,r)]}case"Multinomial":{const n=O("logits",t,e,a),s=O("numSamples",t,e,a),r=O("seed",t,e,a);return[Oe.S(n,s,r)]}case"OneHot":{const n=O("indices",t,e,a),s=O("depth",t,e,a),r=O("onValue",t,e,a),o=O("offValue",t,e,a);return[_e.l(n,s,r,o)]}case"Ones":return[ve.i(O("shape",t,e,a),O("dtype",t,e,a))];case"OnesLike":return[Ie.J(O("x",t,e,a))];case"RandomUniform":return[Ee.L(O("shape",t,e,a),O("minval",t,e,a),O("maxval",t,e,a),O("dtype",t,e,a))];case"Range":{const n=O("start",t,e,a),s=O("stop",t,e,a),r=O("step",t,e,a);return[Ae.w(n,s,r,O("dtype",t,e,a))]}case"TruncatedNormal":{const n=O("shape",t,e,a),s=O("mean",t,e,a),r=O("stdDev",t,e,a),o=O("seed",t,e,a);return[De.X(n,s,r,O("dtype",t,e,a),o)]}case"Zeros":return[ke.l(O("shape",t,e,a),O("dtype",t,e,a))];case"ZerosLike":return[Me.P(O("x",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"dynamic":return(async(t,e,a)=>{switch(t.op){case"NonMaxSuppressionV5":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p,softNmsSigma:i}=Fe(t,e,a),m=await Ve.BHj.nonMaxSuppressionWithScoreAsync(n,s,r,o,p,i);return[m.selectedIndices,m.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Fe(t,e,a),i=O("padToMaxOutputSize",t,e,a),m=await Ve.BHj.nonMaxSuppressionPaddedAsync(n,s,r,o,p,i);return[m.selectedIndices,m.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:n,scores:s,maxOutputSize:r,iouThreshold:o,scoreThreshold:p}=Fe(t,e,a);return[await Ve.BHj.nonMaxSuppressionAsync(n,s,r,o,p)]}case"Where":{const n=Ce.p(O("condition",t,e,a),"bool"),s=[await Le.i(n)];return n.dispose(),s}case"ListDiff":return Pe.O(O("x",t,e,a),O("y",t,e,a));default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a);case"evaluation":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"TopKV2":{const n=O("x",t,e,a),s=O("k",t,e,a),r=O("sorted",t,e,a),o=ze.h(n,s,r);return[o.values,o.indices]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"image":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"ResizeBilinear":{const n=O("images",t,e,a),s=O("size",t,e,a),r=O("alignCorners",t,e,a);return[Ve.BHj.resizeBilinear(n,[s[0],s[1]],r)]}case"ResizeNearestNeighbor":{const n=O("images",t,e,a),s=O("size",t,e,a),r=O("alignCorners",t,e,a);return[Ve.BHj.resizeNearestNeighbor(n,[s[0],s[1]],r)]}case"CropAndResize":{const n=O("image",t,e,a),s=O("boxes",t,e,a),r=O("boxInd",t,e,a),o=O("cropSize",t,e,a),p=O("method",t,e,a),i=O("extrapolationValue",t,e,a);return[Ve.BHj.cropAndResize(n,s,r,o,p,i)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"graph":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Const":return e[t.name];case"PlaceholderWithDefault":const n=O("default",t,e,a);return[_(t.name,e,a)||n];case"Placeholder":return[_(t.name,e,a)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":return[D(O("x",t,e,a))];case"IdentityN":return O("x",t,e,a).map((t=>D(t)));case"Snapshot":return[D(O("x",t,e,a))];case"Shape":return[$e.R(O("x",t,e,a).shape,"int32")];case"ShapeN":return O("x",t,e,a).map((t=>$e.R(t.shape)));case"Size":return[Be.i(O("x",t,e,a).size,"int32")];case"Rank":return[Be.i(O("x",t,e,a).rank,"int32")];case"NoOp":return[Be.i(1)];case"Print":const s=O("x",t,e,a),r=O("data",t,e,a),o=O("message",t,e,a),p=O("summarize",t,e,a);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(o);for(let t=0;t<r.length;t++)console.log(Array.prototype.slice.call(r[t].dataSync()).slice(0,p));return[s];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"logical":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Equal":return[Re.D(O("a",t,e,a),O("b",t,e,a))];case"NotEqual":return[je.Q(O("a",t,e,a),O("b",t,e,a))];case"Greater":return[We.p(O("a",t,e,a),O("b",t,e,a))];case"GreaterEqual":return[He.b(O("a",t,e,a),O("b",t,e,a))];case"Less":return[Ge.d(O("a",t,e,a),O("b",t,e,a))];case"LessEqual":return[Ue.z(O("a",t,e,a),O("b",t,e,a))];case"LogicalAnd":return[qe.H(O("a",t,e,a),O("b",t,e,a))];case"LogicalNot":return[Ke.h(O("a",t,e,a))];case"LogicalOr":return[Qe.K(O("a",t,e,a),O("b",t,e,a))];case"Select":case"SelectV2":return[Xe.a(O("condition",t,e,a),O("a",t,e,a),O("b",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"matrices":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[Ye.O(O("a",t,e,a),O("b",t,e,a),O("transposeA",t,e,a),O("transposeB",t,e,a))];case"Transpose":return[Ze.p(O("x",t,e,a),O("perm",t,e,a))];case"_FusedMatMul":const[n,s]=O("fusedOps",t,e,a),r="biasadd"===n,o="prelu"===s,p=O("numArgs",t,e,a);if(r){if(o&&2!==p)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!o&&1!==p)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[i,m]=O("args",t,e,a);return[de.matMul({a:O("a",t,e,a),b:O("b",t,e,a),transposeA:O("transposeA",t,e,a),transposeB:O("transposeB",t,e,a),bias:i,activation:s,preluActivationWeights:m})];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"normalization":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[Je.t(O("x",t,e,a),O("mean",t,e,a),O("variance",t,e,a),O("offset",t,e,a),O("scale",t,e,a),O("epsilon",t,e,a))];case"LRN":return[ta.G(O("x",t,e,a),O("radius",t,e,a),O("bias",t,e,a),O("alpha",t,e,a),O("beta",t,e,a))];case"Softmax":return[ea.X(O("x",t,e,a))];case"LogSoftmax":return[aa.C(O("x",t,e,a))];case"SparseToDense":return[na.e(O("sparseIndices",t,e,a),O("outputShape",t,e,a),O("sparseValues",t,e,a),O("defaultValue",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"reduction":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Max":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[sa.F(O("x",t,e,a),n,s)]}case"Mean":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[ra.J(O("x",t,e,a),n,s)]}case"Min":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[oa.V(O("x",t,e,a),n,s)]}case"Sum":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[pa.S(O("x",t,e,a),n,s)]}case"All":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[ia.$(O("x",t,e,a),n,s)]}case"Any":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[ma.Y(O("x",t,e,a),n,s)]}case"ArgMax":{const n=O("axis",t,e,a);return[ua.N(O("x",t,e,a),n)]}case"ArgMin":{const n=O("axis",t,e,a);return[da.v(O("x",t,e,a),n)]}case"Prod":{const n=O("axis",t,e,a),s=O("keepDims",t,e,a);return[ne.W(O("x",t,e,a),n,s)]}case"Cumsum":{const n=O("axis",t,e,a),s=O("exclusive",t,e,a),r=O("reverse",t,e,a);return[ca.z(O("x",t,e,a),n,s,r)]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"slice_join":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"ConcatV2":case"Concat":{const n=O("n",t,e,a),s=O("axis",t,e,a);let r=O("tensors",t,e,a);return r=r.slice(0,n),[ya.z(r,s)]}case"GatherV2":case"Gather":{const n=O("axis",t,e,a),s=O("x",t,e,a),r=O("indices",t,e,a);return[la.I(s,Ce.p(r,"int32"),n)]}case"ReverseV2":case"Reverse":{const n=O("axis",t,e,a),s=O("x",t,e,a);return[ha.G(s,n)]}case"Slice":{const n=O("begin",t,e,a),s=O("size",t,e,a);return[fa.t(O("x",t,e,a),n,s)]}case"StridedSlice":{const n=O("begin",t,e,a),s=O("end",t,e,a),r=O("strides",t,e,a),o=O("beginMask",t,e,a),p=O("endMask",t,e,a),i=O("ellipsisMask",t,e,a),m=O("newAxisMask",t,e,a),u=O("shrinkAxisMask",t,e,a),d=O("x",t,e,a);return[ga.N(d,n,s,r,o,p,i,m,u)]}case"Pack":return(0,T.tidy)((()=>{const n=O("axis",t,e,a),s=O("tensors",t,e,a),r=s[0].shape,o=Na.L(s[0]).shape,p=s.map((t=>{const e=T.util.arraysEqual(t.shape,r);if(!e&&!T.util.arraysEqual(Na.L(t).shape,o))throw new Error("the input tensors shape does not match");return e?t:xa.X(t,r)}));return[ba.k(p,n)]}));case"Unpack":{const n=O("axis",t,e,a),s=O("tensor",t,e,a);return Ta.H(s,n)}case"Tile":{const n=O("reps",t,e,a);return[Sa.G(O("x",t,e,a),n)]}case"Split":case"SplitV":{const n=O("axis",t,e,a),s=O("numOrSizeSplits",t,e,a),r=O("x",t,e,a);return wa.V(r,s,n)}case"ScatterNd":{const n=O("indices",t,e,a),s=O("values",t,e,a),r=O("shape",t,e,a);return[Oa.s(n,s,r)]}case"GatherNd":{const n=O("x",t,e,a),s=O("indices",t,e,a);return[_a.d(n,s)]}case"SparseToDense":{const n=O("sparseIndices",t,e,a),s=O("outputShape",t,e,a),r=O("sparseValues",t,e,a),o=O("defaultValue",t,e,a);return[na.e(n,r,s,r.dtype===o.dtype?o:Ce.p(o,r.dtype))]}default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"spectral":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"FFT":return[va.k(O("x",t,e,a))];case"IFFT":return[Ia.S(O("x",t,e,a))];case"RFFT":return[Ea.Q(O("x",t,e,a))];case"IRFFT":return[Aa.w(O("x",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"transformation":return T.tidy((()=>((t,e,a)=>{switch(t.op){case"Cast":return[Ce.p(O("x",t,e,a),O("dtype",t,e,a))];case"ExpandDims":{const n=O("axis",t,e,a);return[Da.d(O("x",t,e,a),n)]}case"Squeeze":{const n=O("axis",t,e,a);return[Na.L(O("x",t,e,a),n)]}case"Reshape":return[xa.X(O("x",t,e,a),O("shape",t,e,a))];case"PadV2":case"Pad":return[ka.v(O("x",t,e,a),O("padding",t,e,a),O("constantValue",t,e,a))];case"SpaceToBatchND":{const n=O("blockShape",t,e,a),s=O("paddings",t,e,a);return[Ma.f(O("x",t,e,a),n,s)]}case"BatchToSpaceND":{const n=O("blockShape",t,e,a),s=O("crops",t,e,a);return[Va.E(O("x",t,e,a),n,s)]}case"DepthToSpace":{const n=O("blockSize",t,e,a),s=O("dataFormat",t,e,a).toUpperCase();return[Ca.n(O("x",t,e,a),n,s)]}case"BroadcastTo":return[La.U(O("x",t,e,a),O("shape",t,e,a))];default:throw TypeError(`Node type ${t.op} is not implemented`)}})(t,e,a)));case"custom":const n=w(t.op);if(n&&n.customExecutor)return n.customExecutor(new pt(t,e,a));throw TypeError(`Custom op ${t.op} is not registered.`);default:throw TypeError(`Unknown op '${t.op}'. File an issue at https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()`)}})(t,e,a);return n instanceof Promise?n.then((t=>[].concat(t))):[].concat(n)}class Fa{constructor(t={},e={},a={},n={}){this.weightMap=t,this.tensorArrayMap=e,this.tensorListMap=a,this.functionMap=n,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(t,e){return{id:t,frameName:e,iterationId:0}}set currentContext(t){this.contexts!==t&&(this.contexts=t,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const t=[];for(let e=0;e<this.contexts.length-1;e++){const a=this.contexts.slice(0,this.contexts.length-e);t.push(this.contextIdforContexts(a))}t.push(""),this._currentContextIds=t}contextIdforContexts(t){return t?t.map((t=>0===t.id&&0===t.iterationId?"":`${t.frameName}-${t.iterationId}`)).join("/"):""}enterFrame(t){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,t)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const t=Object.assign({},this.contexts[this.contexts.length-1]);t.iterationId+=1,t.id=this.lastId,this.contexts.splice(-1,1,t),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(t){return this.weightMap[t]}addTensorArray(t){this.tensorArrayMap[t.id]=t}getTensorArray(t){return this.tensorArrayMap[t]}addTensorList(t){this.tensorListMap[t.id]=t}getTensorList(t){return this.tensorListMap[t]}dispose(t){for(const e in this.tensorArrayMap)this.tensorArrayMap[e].clearAndClose(t);for(const e in this.tensorListMap)this.tensorListMap[e].clearAndClose(t)}}function za(t,e,a){const n=new Set,s=[];let r=null,o=null;const p=new Set,i=Object.keys(t).map((t=>E(t)[0])),m=[...e];for(;m.length>0;){const t=m.pop();(Ra(t)||ja(t))&&null==r&&(r=t,o=r.children.map((t=>t.name)).filter((t=>n.has(t)))),n.add(t.name),null==a[t.name]&&-1===i.indexOf(t.name)&&(0!==t.inputs.length?t.inputs.forEach((t=>{p.has(t.name)||(p.add(t.name),m.push(t))})):s.push(t.name))}return{inputs:t,outputs:e,usedNodes:n,missingInputs:s,dynamicNode:r,syncInputs:o}}const $a=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],Ba=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"];function Ra(t){return $a.indexOf(t.op)>=0}function ja(t){return Ba.indexOf(t.op)>=0}class Wa{constructor(t,e){this.graph=t,this.parent=e,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this._outputs=t.outputs,this._inputs=t.inputs,this._signature=t.signature,this._functions=t.functions,null!=t.functions&&Object.keys(t.functions).forEach((e=>{this._functionExecutorMap[e]=new Wa(t.functions[e],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(t){const e=Object.keys(t).map((e=>t[e].map((t=>t.id))));this._weightIds=[].concat(...e),this._weightMap=t}get inputs(){return this._inputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((t=>({name:t.name,shape:t.attrParams.shape?t.attrParams.shape.value:void 0,dtype:t.attrParams.dtype?t.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((t=>t.signatureKey||t.name))}get outputNodes(){return this._outputs.map((t=>{const e=t.signatureKey||t.name;return t.defaultOutput?`${e}:${t.defaultOutput}`:e}))}get functions(){return Object.keys(this._functions).reduce(((t,e)=>(t[e]=this._functions[e].signature,t)),{})}getCompilationKey(t,e){const a=t.map((t=>t.name)).sort(),n=e.map((t=>t.name)).sort();return a.join(this.SEPERATOR)+"--"+n.join(this.SEPERATOR)}compile(t,e){const a=za(t,e,this.weightMap),{missingInputs:n,dynamicNode:s,syncInputs:r}=a;if(null!=s)throw new Error(`This execution contains the node '${s.name}', which has the dynamic op '${s.op}'. Please use model.executeAsync() instead. Alternatively, to avoid the dynamic ops, specify the inputs [${r}]`);if(n.length>0){const a=e.map((t=>t.name)),s=Object.keys(t);throw new Error(`Cannot compute the outputs [${a}] from the provided inputs [${s}]. Missing the following inputs: [${n}]`)}return function(t,e,a){const{usedNodes:n,inputs:s}=a,r=[];Object.keys(s).map((t=>E(t)[0])).map((e=>t.nodes[e])).forEach((t=>{n.has(t.name)&&r.push(t)})),t.weights.forEach((t=>{n.has(t.name)&&r.push(t)}));const o=new Set,p=[];for(;r.length>0;){const t=r.pop();o.add(t.name),e[t.name]||p.push(t),t.children.forEach((t=>{!o.has(t.name)&&n.has(t.name)&&t.inputs.every((t=>o.has(t.name)))&&r.push(t)}))}return p}(this.graph,this.weightMap,a)}execute(t,e){t=this.mapInputs(t);const a=Object.keys(t).sort();this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e);const n=a.map((t=>this.graph.nodes[E(t)[0]])),s=e.map((t=>this.graph.nodes[E(t)[0]])),r=this.getCompilationKey(n,s);let o=this.compiledMap.get(r);null==o&&(o=this.compile(t,s),this.compiledMap.set(r,o));const p={},i={};return(0,T.tidy)((()=>{const a=new Fa(this.weightMap,p,i,this.functionExecutorMap),n=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,s]=E(e),r=[];r[s]=t[e],n[a]=r}));const s=this.getFrozenTensorIds(n),r={};for(let t=0;t<o.length;t++){const p=o[t];if(!n[p.name]){const t=Pa(p,n,a);if(t instanceof Promise)throw new Error(`The execution of the op '${p.op}' returned a promise. Please use model.executeAsync() instead.`);n[p.name]=t,this.checkTensorForDisposal(p.name,p,n,a,s,e,r)}}return null==this.parent&&a.dispose(s),e.map((t=>_(t,n,a)))}))}getFrozenTensorIds(t){const e=[].concat.apply([],Object.keys(t).map((e=>t[e])).map((t=>t.map((t=>t.id)))));return new Set(e)}checkTensorForDisposal(t,e,a,n,s,r,o){"control"!==e.category&&-1===r.indexOf(t)&&(a[t].forEach((t=>{null!=t&&(o[t.id]=(o[t.id]||0)+e.children.length)})),e.inputs.forEach((t=>{if("control"!==t.category){const e=function(t,e,a){return e[I(t,a.currentContextId)]}(t.name,a,n);null!=e&&e.forEach((t=>{if(t&&!s.has(t.id)){const e=o[t.id];1===e?(t.dispose(),delete o[t.id]):null!=e&&o[t.id]--}}))}})))}async executeAsync(t,e){return this._executeAsync(t,e)}async _executeAsync(t,e,a=!1,n={},s={}){a||(t=this.mapInputs(t),this.checkInputs(t),this.checkInputShapeAndType(t),e=this.mapOutputs(e),this.checkOutputs(e));const r=new Fa(this.weightMap,n,s,this.functionExecutorMap),o=await this.executeWithControlFlow(t,r,e,a),p=e.map((t=>_(t,o,r))),i=p.map((t=>t.id)),m=Object.keys(t).map((e=>t[e].id)),u=new Set([...i,...m,...this.weightIds]);return Object.keys(o).forEach((t=>{o[t].forEach((t=>{!t||t.isDisposed||u.has(t.id)||t.dispose()}))})),null==this.parent&&r.dispose(u),p}async executeFunctionAsync(t,e,a){const n=t.reduce(((t,e,a)=>(t[this.inputs[a].name]=e,t)),{});return this._executeAsync(n,this.outputNodes,!0,e,a)}async executeWithControlFlow(t,e,a,n){const s=Object.keys(t),r=s.map((t=>this.graph.nodes[E(t)[0]])),o=a.map((t=>this.graph.nodes[E(t)[0]])),{usedNodes:p,missingInputs:i,dynamicNode:m,syncInputs:u}=za(t,o,this.weightMap),d=[...r,...this.graph.weights].map((t=>({node:t,contexts:e.currentContext}))),c=Object.assign({},this.weightMap);Object.keys(t).forEach((e=>{const[a,n]=E(e),s=[];s[n]=t[e],c[a]=s}));const y={},l=this.getFrozenTensorIds(c),h={};for(;d.length>0;){const t=this.processStack(r,d,e,c,h,l,a,y,p);await Promise.all(t)}null!=m||n||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const f=o.filter((t=>!Ra(t)&&!_(t.name,c,e))).map((t=>t.name));if(f.length>0){let t="";throw null!=m&&(t=`Alternatively, to avoid the dynamic ops, use model.execute() and specify the inputs [${u}]`),new Error(`Cannot compute the outputs [${f}] from the provided inputs [${s}]. Consider providing the following inputs: [${i}]. ${t}`)}return c}processStack(t,e,a,n,s,r,o,p,i){const m=[];for(;e.length>0;){const u=e.pop();a.currentContext=u.contexts;let d="";if("Enter"===u.node.op&&O("isConstant",u.node,n,a)&&([d]=v(u.node.name,a)),-1===t.indexOf(u.node)){const t=Pa(u.node,n,a);d||([d]=v(u.node.name,a));const c=a.currentContext;t instanceof Promise?m.push(t.then((t=>(n[d]=t,a.currentContext=c,this.checkTensorForDisposal(d,u.node,n,a,r,o,p),this.processChildNodes(u.node,e,a,n,s,i),t)))):(n[d]=t,this.checkTensorForDisposal(d,u.node,n,a,r,o,p),this.processChildNodes(u.node,e,a,n,s,i))}else this.processChildNodes(u.node,e,a,n,s,i)}return m}processChildNodes(t,e,a,n,s,r){t.children.forEach((t=>{const[o]=v(t.name,a);!s[o]&&r.has(t.name)&&("Merge"===t.op?t.inputNames.some((t=>!!_(t,n,a)))&&(s[o]=!0,e.push({contexts:a.currentContext,node:t})):t.inputNames.every((t=>!!_(t,n,a)))&&(s[o]=!0,e.push({contexts:a.currentContext,node:t})))}))}dispose(){Object.keys(this.weightMap).forEach((t=>this.weightMap[t].forEach((t=>t.dispose()))))}checkInputShapeAndType(t){Object.keys(t).forEach((e=>{const a=t[e],[n]=E(e),s=this.graph.nodes[n];if(s.attrParams.shape&&s.attrParams.shape.value){const t=s.attrParams.shape.value,e=t.length===a.shape.length&&a.shape.every(((e,a)=>-1===t[a]||t[a]===e));T.util.assert(e,(()=>`The shape of dict['${s.name}'] provided in model.execute(dict) must be [${t}], but was [${a.shape}]`))}s.attrParams.dtype&&s.attrParams.dtype.value&&T.util.assert(a.dtype===s.attrParams.dtype.value,(()=>`The dtype of dict['${s.name}'] provided in model.execute(dict) must be ${s.attrParams.dtype.value}, but was ${a.dtype}`))}))}mapInputs(t){const e={};for(const a in t)null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[a]?e[this._signature.inputs[a].name]=t[a]:e[a]=t[a];return e}checkInputs(t){const e=Object.keys(t).filter((t=>{const[e]=E(t);return null==this.graph.nodes[e]}));if(e.length>0)throw new Error(`The dict provided in model.execute(dict) has keys: [${e}] that are not part of graph`)}mapOutputs(t){return t.map((t=>null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[t]?this._signature.outputs[t].name:t),{})}checkOutputs(t){t.forEach((t=>{const[e]=E(t);if(!this.graph.nodes[e])throw new Error(`The output '${t}' is not found in the graph`)}))}}class Ha{constructor(t,e={}){this.modelUrl=t,this.loadOptions=e,this.version="n/a",null==e&&(this.loadOptions={})}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}findIOHandler(){const t=this.modelUrl;if(null!=t.load)this.handler=t;else if(null!=this.loadOptions.requestInit)this.handler=T.io.browserHTTPRequest(t,this.loadOptions);else{const e=T.io.getLoadHandlers(t,this.loadOptions);if(0===e.length)e.push(T.io.browserHTTPRequest(t,this.loadOptions));else if(e.length>1)throw new Error(`Found more than one (${e.length}) load handlers for URL '${[t]}'`);this.handler=e[0]}}async load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const t=await this.handler.load();return this.loadSync(t)}loadSync(t){this.artifacts=t;const e=this.artifacts.modelTopology;let a={};null!=this.artifacts.userDefinedMetadata&&(a=this.artifacts.userDefinedMetadata.signature),this.version=`${e.versions.producer}.${e.versions.minConsumer}`;const x=T.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);return this.executor=new Wa(class{static get Instance(){return this._instance||(this._instance=new this)}constructor(){const t=[].concat(...[n,s,r,o,p,i,m,c,d,u,y,l,h,f,g,N].map((t=>t.json)));this.opMappers=t.reduce(((t,e)=>(t[e.tfOpName]=e,t)),{})}transformGraph(t,e={}){const a=t.node,n=[],s=[],r=a.reduce(((t,e)=>(t[e.name]=this.mapNode(e),e.op.startsWith("Placeholder")&&n.push(t[e.name]),"Const"===e.op&&s.push(t[e.name]),t)),{});let o=[];const p=[];let i={},m={};null!=e&&(i=this.mapSignatureEntries(e.inputs),m=this.mapSignatureEntries(e.outputs));const u=Object.keys(r);u.forEach((t=>{const e=r[t];e.inputNames.forEach((t=>{const[a]=v(t);e.inputs.push(r[a]),r[a].children.push(e)}))})),0===Object.keys(m).length?u.forEach((t=>{const e=r[t];0===e.children.length&&p.push(e)})):Object.keys(m).forEach((t=>{const[e]=v(t),a=r[e];null!=a&&(a.signatureKey=m[t],p.push(a))})),Object.keys(i).length>0?Object.keys(i).forEach((t=>{const[e]=v(t),a=r[e];a&&(a.signatureKey=i[t],o.push(a))})):o=n;let d={};return null!=t.library&&null!=t.library.function&&(d=t.library.function.reduce(((t,e)=>(t[e.signature.name]=this.mapFunction(e),t)),{})),{nodes:r,inputs:o,outputs:p,weights:s,placeholders:n,signature:e,functions:d}}mapSignatureEntries(t){return Object.keys(t||{}).reduce(((e,a)=>(e[t[a].name]=a,e)),{})}mapNode(t){const e=w(t.op)||this.opMappers[t.op]||{};null==t.attr&&(t.attr={});const a={name:t.name,op:t.op,category:e.category,inputNames:(t.input||[]).map((t=>t.startsWith("^")?t.substr(1):t)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:t.attr};return null!=e.inputs&&(a.inputParams=e.inputs.reduce(((t,e)=>(t[e.name]={type:e.type,inputIndexStart:e.start,inputIndexEnd:e.end},t)),{})),null!=e.attrs&&(a.attrParams=e.attrs.reduce(((e,a)=>{const n=a.type;let s;switch(a.type){case"string":s=K(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=K(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"string[]":s=st(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=st(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number":s=X(t.attr,a.tfName,a.defaultValue||0),void 0===s&&a.tfDeprecatedName&&(s=X(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"number[]":s=nt(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=nt(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool":s=Q(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Q(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"bool[]":s=ot(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=ot(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape":s=at(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=at(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"shape[]":s=rt(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=rt(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype":s=J(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=J(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"dtype[]":s=tt(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=tt(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"func":s=Z(t.attr,a.tfName,a.defaultValue),void 0===s&&a.tfDeprecatedName&&(s=Z(t.attr,a.tfDeprecatedName,a.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error(`Unsupported param type: ${a.type} for op: ${t.op}`)}return e[a.name]={value:s,type:n},e}),{})),a}mapFunction(t){const e=t.nodeDef,a=[];let n={};null!=e&&(n=e.reduce(((t,e)=>(t[e.name]=this.mapNode(e),"Const"===e.op&&a.push(t[e.name]),t)),{}));const s=[],r=[];t.signature.inputArg.forEach((t=>{const[e]=v(t.name),a={name:e,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:Y(t.type),type:"dtype"}},children:[]};a.signatureKey=t.name,s.push(a),n[e]=a})),Object.keys(n).forEach((t=>{const e=n[t];e.inputNames.forEach((t=>{const[a]=v(t);e.inputs.push(n[a]),n[a].children.push(e)}))}));const o=t.ret;t.signature.outputArg.forEach((t=>{const[e,a]=v(o[t.name]),s=n[e];null!=s&&(s.defaultOutput=a,r.push(s))}));const p=this.mapArgsToSignature(t);return{nodes:n,inputs:s,outputs:r,weights:a,placeholders:[],signature:p}}mapArgsToSignature(t){return{methodName:t.signature.name,inputs:t.signature.inputArg.reduce(((t,e)=>(t[e.name]=this.mapArgToTensorInfo(e),t)),{}),outputs:t.signature.outputArg.reduce(((e,a)=>(e[a.name]=this.mapArgToTensorInfo(a,t.ret),e)),{})}}mapArgToTensorInfo(t,e){let a=t.name;return null!=e&&(a=e[a]),{name:a,dtype:t.type}}}.Instance.transformGraph(e,a)),this.executor.weightMap=this.convertTensorMapToTensorsMap(x),!0}async save(t,e){if("string"==typeof t){const e=T.io.getSaveHandlers(t);if(0===e.length)throw new Error(`Cannot find any save handlers for URL '${t}'`);if(e.length>1)throw new Error(`Found more than one (${e.length}) save handlers for URL '${t}'`);t=e[0]}if(null==t.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return t.save(this.artifacts)}predict(t,e){return this.execute(t,this.outputNodes)}normalizeInputs(t){if(!(t instanceof T.Tensor||Array.isArray(t)))return t;if((t=Array.isArray(t)?t:[t]).length!==this.inputNodes.length)throw new Error(`Input tensor count mismatch,the graph model has ${this.inputNodes.length} placeholders, while there are ${t.length} input tensors.`);return this.inputNodes.reduce(((e,a,n)=>(e[a]=t[n],e)),{})}normalizeOutputs(t){return t=t||this.outputNodes,Array.isArray(t)?t:[t]}execute(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=this.executor.execute(t,e);return a.length>1?a:a[0]}async executeAsync(t,e){t=this.normalizeInputs(t),e=this.normalizeOutputs(e);const a=await this.executor.executeAsync(t,e);return a.length>1?a:a[0]}convertTensorMapToTensorsMap(t){return Object.keys(t).reduce(((e,a)=>(e[a]=[t[a]],e)),{})}dispose(){this.executor.dispose()}}async function Ga(t,e={}){if(null==t)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==e&&(e={}),e.fromTFHub&&null==t.load&&(t.endsWith("/")||(t+="/"),t=`${t}model.json?tfjs-format=file`);const a=new Ha(t,e);return await a.load(),a}function Ua(t,e,a,n){return new(a||(a=Promise))((function(s,r){function o(t){try{i(n.next(t))}catch(t){r(t)}}function p(t){try{i(n.throw(t))}catch(t){r(t)}}function i(t){var e;t.done?s(t.value):(e=t.value,e instanceof a?e:new a((function(t){t(e)}))).then(o,p)}i((n=n.apply(t,e||[])).next())}))}function qa(t,e){var a,n,s,r,o={label:0,sent:function(){if(1&s[0])throw s[1];return s[1]},trys:[],ops:[]};return r={next:p(0),throw:p(1),return:p(2)},"function"==typeof Symbol&&(r[Symbol.iterator]=function(){return this}),r;function p(r){return function(p){return function(r){if(a)throw new TypeError("Generator is already executing.");for(;o;)try{if(a=1,n&&(s=2&r[0]?n.return:r[0]?n.throw||((s=n.return)&&s.call(n),0):n.next)&&!(s=s.call(n,r[1])).done)return s;switch(n=0,s&&(r=[2&r[0],s.value]),r[0]){case 0:case 1:s=r;break;case 4:return o.label++,{value:r[1],done:!1};case 5:o.label++,n=r[1],r=[0];continue;case 7:r=o.ops.pop(),o.trys.pop();continue;default:if(!((s=(s=o.trys).length>0&&s[s.length-1])||6!==r[0]&&2!==r[0])){o=0;continue}if(3===r[0]&&(!s||r[1]>s[0]&&r[1]<s[3])){o.label=r[1];break}if(6===r[0]&&o.label<s[1]){o.label=s[1],s=r;break}if(s&&o.label<s[2]){o.label=s[2],o.ops.push(r);break}s[2]&&o.ops.pop(),o.trys.pop();continue}r=e.call(t,o)}catch(t){r=[6,t],n=0}finally{a=s=0}if(5&r[0])throw r[1];return{value:r[0]?r[1]:void 0,done:!0}}([r,p])}}}function Ka(t){return[Math.abs(t.endPoint[0]-t.startPoint[0]),Math.abs(t.endPoint[1]-t.startPoint[1])]}function Qa(t){return[t.startPoint[0]+(t.endPoint[0]-t.startPoint[0])/2,t.startPoint[1]+(t.endPoint[1]-t.startPoint[1])/2]}function Xa(t,e){void 0===e&&(e=1.5);var a=Qa(t),n=Ka(t),s=[e*n[0]/2,e*n[1]/2];return{startPoint:[a[0]-s[0],a[1]-s[1]],endPoint:[a[0]+s[0],a[1]+s[1]],palmLandmarks:t.palmLandmarks}}function Ya(t){var e=Qa(t),a=Ka(t),n=Math.max.apply(Math,a)/2;return{startPoint:[e[0]-n,e[1]-n],endPoint:[e[0]+n,e[1]+n],palmLandmarks:t.palmLandmarks}}function Za(t,e){var a=[t.endPoint[0]-t.startPoint[0],t.endPoint[1]-t.startPoint[1]],n=[a[0]*e[0],a[1]*e[1]];return{startPoint:[t.startPoint[0]+n[0],t.startPoint[1]+n[1]],endPoint:[t.endPoint[0]+n[0],t.endPoint[1]+n[1]],palmLandmarks:t.palmLandmarks}}var Ja=function(){function t(t,e,a,n,s,r){this.model=t,this.width=e,this.height=a,this.iouThreshold=s,this.scoreThreshold=r,this.anchors=n.map((function(t){return[t.x_center,t.y_center]})),this.anchorsTensor=(0,T.tensor2d)(this.anchors),this.inputSizeTensor=(0,T.tensor1d)([e,a]),this.doubleInputSizeTensor=(0,T.tensor1d)([2*e,2*a])}return t.prototype.normalizeBoxes=function(t){var e=this;return(0,T.tidy)((function(){var a=(0,T.slice)(t,[0,0],[-1,2]),n=(0,T.slice)(t,[0,2],[-1,2]),s=(0,T.add)((0,T.div)(a,e.inputSizeTensor),e.anchorsTensor),r=(0,T.div)(n,e.doubleInputSizeTensor),o=(0,T.mul)((0,T.sub)(s,r),e.inputSizeTensor),p=(0,T.mul)((0,T.add)(s,r),e.inputSizeTensor);return(0,T.concat2d)([o,p],1)}))},t.prototype.normalizeLandmarks=function(t,e){var a=this;return(0,T.tidy)((function(){var n=(0,T.add)((0,T.div)(t.reshape([-1,7,2]),a.inputSizeTensor),a.anchors[e]);return(0,T.mul)(n,a.inputSizeTensor)}))},t.prototype.getBoundingBoxes=function(t){return Ua(this,void 0,void 0,(function(){var e,a,n,s,r,o,p,i,m,u,d,c,y,l,h,f=this;return qa(this,(function(g){switch(g.label){case 0:return e=(0,T.tidy)((function(){return(0,T.mul)((0,T.sub)(t,.5),2)})),"webgl"===(0,T.getBackend)()?(n=(0,T.env)().get("WEBGL_PACK_DEPTHWISECONV"),(0,T.env)().set("WEBGL_PACK_DEPTHWISECONV",!0),a=this.model.predict(e),(0,T.env)().set("WEBGL_PACK_DEPTHWISECONV",n)):a=this.model.predict(e),s=a.squeeze(),r=(0,T.tidy)((function(){return(0,T.sigmoid)((0,T.slice)(s,[0,0],[-1,1])).squeeze()})),o=(0,T.slice)(s,[0,1],[-1,4]),p=this.normalizeBoxes(o),i=console.warn,console.warn=function(){},m=T.image.nonMaxSuppression(p,r,1,this.iouThreshold,this.scoreThreshold),console.warn=i,[4,m.array()];case 1:return u=g.sent(),d=[e,a,m,s,p,o,r],0===u.length?(d.forEach((function(t){return t.dispose()})),[2,null]):(c=u[0],y=(0,T.slice)(p,[c,0],[1,-1]),l=(0,T.slice)(s,[c,5],[1,14]),h=(0,T.tidy)((function(){return f.normalizeLandmarks(l,c).reshape([-1,2])})),d.push(l),d.forEach((function(t){return t.dispose()})),[2,{boxes:y,palmLandmarks:h}])}}))}))},t.prototype.estimateHandBounds=function(t){return Ua(this,void 0,void 0,(function(){var e,a,n,s,r,o,p,i,m=this;return qa(this,(function(u){switch(u.label){case 0:return e=t.shape[1],a=t.shape[2],n=(0,T.tidy)((function(){return t.resizeBilinear([m.width,m.height]).div(255)})),[4,this.getBoundingBoxes(n)];case 1:return null===(s=u.sent())?(n.dispose(),[2,null]):(r=s.boxes.arraySync(),o=r[0].slice(0,2),p=r[0].slice(2,4),i=s.palmLandmarks.arraySync(),n.dispose(),s.boxes.dispose(),s.palmLandmarks.dispose(),[2,(d={startPoint:o,endPoint:p,palmLandmarks:i},c=[a/this.width,e/this.height],{startPoint:[d.startPoint[0]*c[0],d.startPoint[1]*c[1]],endPoint:[d.endPoint[0]*c[0],d.endPoint[1]*c[1]],palmLandmarks:d.palmLandmarks.map((function(t){return[t[0]*c[0],t[1]*c[1]]}))})])}var d,c}))}))},t}(),tn={thumb:[1,2,3,4],indexFinger:[5,6,7,8],middleFinger:[9,10,11,12],ringFinger:[13,14,15,16],pinky:[17,18,19,20],palmBase:[0]},en=function(t,e){return[[1,0,t],[0,1,e],[0,0,1]]};function an(t,e){for(var a=0,n=0;n<t.length;n++)a+=t[n]*e[n];return a}function nn(t,e){for(var a=[],n=0;n<t.length;n++)a.push(t[n][e]);return a}function sn(t,e){for(var a=[],n=t.length,s=0;s<n;s++){a.push([]);for(var r=0;r<n;r++)a[s].push(an(t[s],nn(e,r)))}return a}function rn(t,e){var a=Math.cos(t),n=Math.sin(t),s=[[a,-n,0],[n,a,0],[0,0,1]],r=sn(en(e[0],e[1]),s);return sn(r,en(-e[0],-e[1]))}function on(t,e){return[an(t,e[0]),an(t,e[1])]}var pn=[0,-.4],mn=[0,-.1],un=[0,5,9,13,17,1,2],dn=function(){function t(t,e,a,n,s,r){this.regionsOfInterest=[],this.runsWithoutHandDetector=0,this.boundingBoxDetector=t,this.meshDetector=e,this.maxContinuousChecks=s,this.detectionConfidence=r,this.meshWidth=a,this.meshHeight=n,this.maxHandsNumber=1}return t.prototype.getBoxForPalmLandmarks=function(t,e){var a=t.map((function(t){return on(t.concat([1]),e)}));return Xa(Ya(Za(this.calculateLandmarksBoundingBox(a),pn)),3)},t.prototype.getBoxForHandLandmarks=function(t){for(var e=Xa(Ya(Za(this.calculateLandmarksBoundingBox(t),mn)),1.65),a=[],n=0;n<un.length;n++)a.push(t[un[n]].slice(0,2));return e.palmLandmarks=a,e},t.prototype.transformRawCoords=function(t,e,a,n){var s,r,o,p,i=this,m=Ka(e),u=[m[0]/this.meshWidth,m[1]/this.meshHeight],d=t.map((function(t){return[u[0]*(t[0]-i.meshWidth/2),u[1]*(t[1]-i.meshHeight/2),t[2]]})),c=rn(a,[0,0]),y=d.map((function(t){return on(t,c).concat([t[2]])})),l=(r=[[(s=n)[0][0],s[1][0]],[s[0][1],s[1][1]]],o=[s[0][2],s[1][2]],p=[-an(r[0],o),-an(r[1],o)],[r[0].concat(p[0]),r[1].concat(p[1]),[0,0,1]]),h=Qa(e).concat([1]),f=[an(h,l[0]),an(h,l[1])];return y.map((function(t){return[t[0]+f[0],t[1]+f[1],t[2]]}))},t.prototype.estimateHand=function(t){return Ua(this,void 0,void 0,(function(){var e,a,n,s,r,o,p,i,m,u,d,c,y,l,h,f,g,N,x,b;return qa(this,(function(S){switch(S.label){case 0:return!0!==(e=this.shouldUpdateRegionsOfInterest())?[3,2]:[4,this.boundingBoxDetector.estimateHandBounds(t)];case 1:return null===(a=S.sent())?(t.dispose(),this.regionsOfInterest=[],[2,null]):(this.updateRegionsOfInterest(a,!0),this.runsWithoutHandDetector=0,[3,3]);case 2:this.runsWithoutHandDetector++,S.label=3;case 3:return n=this.regionsOfInterest[0],s=function(t,e){var a;return(a=Math.PI/2-Math.atan2(-(e[1]-t[1]),e[0]-t[0]))-2*Math.PI*Math.floor((a+Math.PI)/(2*Math.PI))}(n.palmLandmarks[0],n.palmLandmarks[2]),r=Qa(n),o=[r[0]/t.shape[2],r[1]/t.shape[1]],p=T.image.rotateWithOffset(t,s,0,o),i=rn(-s,r),m=!0===e?this.getBoxForPalmLandmarks(n.palmLandmarks,i):n,u=function(t,e,a){var n=e.shape[1],s=e.shape[2],r=[[t.startPoint[1]/n,t.startPoint[0]/s,t.endPoint[1]/n,t.endPoint[0]/s]];return T.image.cropAndResize(e,r,[0],a)}(m,p,[this.meshWidth,this.meshHeight]),d=u.div(255),u.dispose(),p.dispose(),"webgl"===(0,T.getBackend)()?(y=(0,T.env)().get("WEBGL_PACK_DEPTHWISECONV"),(0,T.env)().set("WEBGL_PACK_DEPTHWISECONV",!0),c=this.meshDetector.predict(d),(0,T.env)().set("WEBGL_PACK_DEPTHWISECONV",y)):c=this.meshDetector.predict(d),l=c[0],h=c[1],d.dispose(),f=l.dataSync()[0],l.dispose(),f<this.detectionConfidence?(h.dispose(),this.regionsOfInterest=[],[2,null]):(g=(0,T.reshape)(h,[-1,3]),N=g.arraySync(),h.dispose(),g.dispose(),x=this.transformRawCoords(N,m,s,i),b=this.getBoxForHandLandmarks(x),this.updateRegionsOfInterest(b,!1),[2,{landmarks:x,handInViewConfidence:f,boundingBox:{topLeft:b.startPoint,bottomRight:b.endPoint}}])}}))}))},t.prototype.calculateLandmarksBoundingBox=function(t){var e=t.map((function(t){return t[0]})),a=t.map((function(t){return t[1]}));return{startPoint:[Math.min.apply(Math,e),Math.min.apply(Math,a)],endPoint:[Math.max.apply(Math,e),Math.max.apply(Math,a)]}},t.prototype.updateRegionsOfInterest=function(t,e){if(e)this.regionsOfInterest=[t];else{var a=this.regionsOfInterest[0],n=0;if(null!=a&&null!=a.startPoint){var s=t.startPoint,r=s[0],o=s[1],p=t.endPoint,i=p[0],m=p[1],u=a.startPoint,d=u[0],c=u[1],y=a.endPoint,l=y[0],h=y[1],f=Math.max(r,d),g=Math.max(o,c),N=(Math.min(i,l)-f)*(Math.min(m,h)-g);n=N/((i-r)*(m-o)+(l-d)*(h-o)-N)}this.regionsOfInterest[0]=n>.8?a:t}},t.prototype.shouldUpdateRegionsOfInterest=function(){return this.regionsOfInterest.length!==this.maxHandsNumber||this.runsWithoutHandDetector>=this.maxContinuousChecks},t}();function cn(){return Ua(this,void 0,void 0,(function(){return qa(this,(function(t){return[2,Ga("https://tfhub.dev/mediapipe/tfjs-model/handdetector/1/default/1",{fromTFHub:!0})]}))}))}function yn(){return Ua(this,void 0,void 0,(function(){return qa(this,(function(t){return[2,Ga("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1",{fromTFHub:!0})]}))}))}function ln(){return Ua(this,void 0,void 0,(function(){return qa(this,(function(t){return[2,T.util.fetch("https://tfhub.dev/mediapipe/tfjs-model/handskeleton/1/default/1/anchors.json?tfjs-format=file").then((function(t){return t.json()}))]}))}))}function hn(t){var e=void 0===t?{}:t,a=e.maxContinuousChecks,n=void 0===a?1/0:a,s=e.detectionConfidence,r=void 0===s?.8:s,o=e.iouThreshold,p=void 0===o?.3:o,i=e.scoreThreshold,m=void 0===i?.5:i;return Ua(this,void 0,void 0,(function(){var t,e,a,s,o,i;return qa(this,(function(u){switch(u.label){case 0:return[4,Promise.all([ln(),cn(),yn()])];case 1:return t=u.sent(),e=t[0],a=t[1],s=t[2],o=new Ja(a,256,256,e,p,m),i=new dn(o,s,256,256,n,r),[2,new fn(i)]}}))}))}var fn=function(){function t(t){this.pipeline=t}return t.getAnnotations=function(){return tn},t.prototype.estimateHands=function(t,e){return void 0===e&&(e=!1),Ua(this,void 0,void 0,(function(){var a,n,s,r,o,p,i,m,u;return qa(this,(function(d){switch(d.label){case 0:return a=function(t){return t instanceof T.Tensor?[t.shape[0],t.shape[1]]:[t.height,t.width]}(t),n=a[1],s=(0,T.tidy)((function(){return t instanceof T.Tensor||(t=T.browser.fromPixels(t)),t.toFloat().expandDims(0)})),[4,this.pipeline.estimateHand(s)];case 1:if(r=d.sent(),s.dispose(),null===r)return[2,[]];for(o=r,!0===e&&(o=function(t,e){var a=t.handInViewConfidence,n=t.landmarks,s=t.boundingBox;return{handInViewConfidence:a,landmarks:n.map((function(t){return[e-1-t[0],t[1],t[2]]})),boundingBox:{topLeft:[e-1-s.topLeft[0],s.topLeft[1]],bottomRight:[e-1-s.bottomRight[0],s.bottomRight[1]]}}}(r,n)),p={},i=0,m=Object.keys(tn);i<m.length;i++)u=m[i],p[u]=tn[u].map((function(t){return o.landmarks[t]}));return[2,[{handInViewConfidence:o.handInViewConfidence,boundingBox:o.boundingBox,landmarks:o.landmarks,annotations:p}]]}}))}))},t}()}}]);